-- !!! TIP !!!  
-- ALWAYS COPY A GOOD PATTERN BEFORE MAKING CHANGES

-- If you 'run' a pattern by itself, without a 'd1' or so, then Tidal
-- will do its best at telling you what's in the first cycle. For
-- example:

note "3"

-- gives:

-- (0>1)|note: 3.0f

-- 0>1 tells you it's an event that starts at position 0 (the start of
-- the first cycle) and lasts up to 1 (the start of the next cycle).
-- note is the name of the 'control' or 'effect' 3.0f is the value
-- ('f' tells you that it's a floating point, decimal number).

note "3 ~ 5"


-- the above gives two events:

-- (0>⅓)|note: 3.0f
-- (⅔>1)|note: 5.0f

-- We can listen to them:
do
d1 $ n (slow 2 $ fmap (*3) $ run 3) # s "supergong" # decay "[1 0.2]/4" # voice "[0.5 0]/8"
d2 $ note "" # s "supergong"
  # sustain 2
  # decay 4
  # accelerate 0.2
  # voice 0.5
d3 $ n "0" # s "superhex"
  # rate 2
  # accelerate 8

-- Tidal Synths:

d1 $ note "g a " # s "supermandolin" 
  # sustain 0.6
  # accelerate 0.3
  # detune 0.2

d1 $ note "a a b c a e f" # s "superpiano"
  # velocity 1 
  # sustain 2
  # detune 0.1

d1 $ n "<0 -14>" # s "supersquare"
  # voice 0.2 -- PWM - 0 or 1 = no sound
  # decay 0.9
  # accelerate 0.01
  # semitone 12
  # resonance 0.2
  # lfo 0.4
  # rate 4.5
  # pitch1 1

d2 $ slow "0 2 4 <5 9> 7 4" $ n "[0 2 4]*64" # s "superchip"
  # slide 0
  # rate 1
  # accelerate 0
  # pitch2 2
  # pitch3 3
  # voice 0.4

d3 $ n " ~ 7 9 11 7 [9 ~ ~ 21]" # s "superfork"
  # accelerate 0

d1 $ n "-12 -15 -14 -12 -10 -8" # s "superhammond"
  -- # perc 1
  -- # percf 2
  -- perc, percf and decay are an attempt at the percussion, no idea if it sounds at all 
  -- reasonable. Vintage Hammonds had percf as 2 or 3 (switchable), two perc levels 
  -- (maybe roughly 0.7 and 1.2?), and two decay options (roughly 0 and maybe 1ish?)
  --vibrato, vrate, perc, percf are all new parameters you’ll need to define in Tidal if you want to change them
  # decay 1
  # voice 1
  --Voices are drawbar presets:
  -- 0: bass violin 16'
  -- 1: tibia 8"
  -- 2: bassoon 8’
  -- 3: french trumpet 8’
  -- 4: string ensemble
  -- 5: Blues
  -- 6: Jazz 1
  -- 7: Full Shout
  -- 8: Bro’ Jack
  -- 9: Jazz 2

d2 $ n "0 7 <5 8 -4 0> 2" # s "supervibe"
  # decay 0
  # velocity 1
  # accelerate 0
  # detune 0.2


d1 $ n "4 5 0 7 9 4 4 3" # s "superhoover"
  # slide 0
  # decay 0.2
  # accelerate 0

d3 $ n "0 5 4 6 8 4" # s "superprimes"
  # voice 1
  # rate 0.2
  # accelerate 0
  # detune 0.2


d1 $ n "2 14 ~ <9 11> 2 9" # s "superwavemechanics"
  # voice 2
  # resonance 0.2
  # accelerate 0
  # detune 0.2

d1 $ n "1 8 13 ~ 25 " # s "superzow"
  # slide 0
  # decay 0.2
  # accelerate 0
  # detune 0.2

d2 $ n "-24" # s "supergrind"
  # slide 0
  # decay 1
  # accelerate 0
  # rate 1

d1 $ every 2 ( slow 2) $ n "12 4 . 2 2 . 4 . 5 " # s "supersaw"
  # voice 0.2 -- PWM - 0 or 1 = no sound
  # decay 0.9
  # accelerate 0.01
  # semitone 12
  # resonance 0.2
  # lfo 0.4
  # rate 4.5
  # pitch1 1

d2 $ n "9 10 12 5" # s "superpwm"
  # voice 0.2 -- PWM - 0 or 1 = no sound
  # decay 0.9
  # accelerate 0.01
  # semitone 12
  # resonance 0.2
  # lfo 0.4
  # rate 4.5
  # pitch1 1

d3 $ n "-12" # s "superscomparator"
  # voice 0.2 -- PWM - 0 or 1 = no sound
  # decay 0.9
  # accelerate 0.01
  # semitone 12
  # resonance 0.2
  # lfo 0.4
  # rate 4.5
  # pitch1 1

d3 $ slow 2 $ n "0 4 5 2 4 5" # s "supertron"
  # octave 3
  # accelerate 0
  # voice 2
  # detune 0.2 

d4 $ n "-24" # s " superreese"
  # accelerate 0
  # voice 0
  # detune 0

d1 $ n "0 0 0*3 9 3 7 2 0" # s "superfm"
  # voice 1
  # lfofreq 2
  # lfodepth 0
  # amp1 1
  # ratio1 2
  # mod11 0.5
  # mod12 0.78
  # detune1 0.2
  # eglevel2 0.1
  # egrate1 0.01

d1 $ n "9 8 2 1" # s "imp"
  # accelerate 1

d1 $ n " 2 -2 -4 -8" # s "psin"
  # accelerate 1

d1 $ n " 2 0 2 3" # s "pmsin"
  # accelerate 1

d1 $ n " 2 [1 ~] -2 -4" # s "gabor"

d1 $ n "0" # s "cyclo"

-- Drum synths
do
d1 $ n "[2 ~ ~ 2 ~ ~ ~ ~ ~ ~ 2 ~ ~ ~ ~ ~]/2" # s "superkick"
  # accelerate 1
  # pitch1 1
  # decay 1
d2 $ n "[0 ~ ~ 0 ~ ~ ~ ~ ~ ~ 0 ~ ~ ~ ~ ~]/2" # s "super808"
  # rate 2
  # voice 0
d3 $ n " [~ ~ ~ ~ 0 ~ ~ ~ ~ ~ ~ ~ 0 ~ ~ ~]/2" # s "supersnare"
  # decay 1 
  # accelerate 0
d4 $ n " [~ ~ ~ ~ ~ ~ ~ 0 ~ 0 ~ ~ ~ ~ ~ ~]/2" # s "superclap"
  # delay 0.2
  # rate 1
  # pitch1 1
d5 $ n "[0 1 2 3 4 3 2 1 0 1 2 3 2 1 0 1*3]/2" # s "superhat"
  # accelerate 1

do
d1 $ midinote "[0 ~ ~ 0 ~ ~ ~ ~ ~ ~ 0 ~ ~ ~ ~ ~]/2" # s "soskick"
  # pitch1 0
  # voice 1
  # pitch2 0
  # speed 0.3
  # freq 65
d2 $ n "[0 1 2 3 4 3 2 1 0 1 2 3 2 1 0 1*3]/2" # s "soshats"
  # resonance 0
  # pitch1 0
  # sustain 0.5
  # freq 220
d3 $ n "~ ~ 0 0" # s "sostoms"
  # voice 0.5
  # sustain 0.5
  # freq 261.626
d4 $ n " ~ 0 " # s "sossnare"
  # voice 0
  # semitone 9
  # pitch1 2000
  # resonance 0.1
  # freq 500
d5 $ n "[0 1 2 3 4 3 2 1 0 1 2 3 2 1 0 1*3]/2" # s "superhat"
  # accelerate 1
d6 $ slow 4 $ n "0" # s "supersiren"
  # sustain 1
d7 $ slow 2 $ s "~ ~ ~ ~ ~ ~ ~ sn:2 ~ ~ ~ sn:1 ~ ~ ~ [sn*3] ~ [ sn:2 sn:3 sn:1 sn:3] ~"

d6 $ slow 8 $ n "0" # s "supernoise"
  # voice 0 -- at 0 n controls rate of digital noise, 1 is brown and white.
  # accelerate 1
  # pitch1 1
  # slide 1
  # resonance 0.1
  # room " 0 0.4"

d6 $ n "0" # s "superstatic"
  # sustain 2


-- Great notes!

-- (.. if you don't hear any, you probably need to install "sc3plugins".)

-- Tidal can also understand note names, and turn them into numbers
-- for you.

-- For example 'c' is the same as '0'

note "c"

-- This:

note "a b c d e f g"

-- is the same as:

note "9 11 0 2 4 5 7"

-- What happened to 1, 3, 6, 8, and 10?
-- You can get to them by adding 's' for 'sharp', to add 1 to a note:

note "cs ds fs gs as"

-- or by using 'f' for 'flat' to subtract 1:

note "df ef gf af bf"

-- In theory, you can get to them all via really sharp 'c'
-- notes. These two notes are identical:
d1 $ note "csssssss g" # s "superpiano"

d1 $ note "gfffffff c" # s "superpiano"

-- In practice, that surely doesn't make a lot of sense.

-- Normally, there are twelve notes in an octave. The default octave
-- is 5, you can pick notes from other octaves by adding a different
-- number:
note "c5 c6 c4 c6"

-- Lets have a listen
d1 $ note "c5 c6 c4 c6" # s "superpiano"

-- Lets think about the difference between 'note', 'n', synths and
-- samples.

-- There is no folder of samples called 'superpiano', the sounds you
-- hear are being synthesised on-the-fly.

-- With synths, you can use either 'note' or 'n' to specify notes,
-- they mean the same thing.

d1 $ n "c a f e" # s "superpiano"

d1 $ note "c a f e" # s "superpiano"

-- For samples, they mean something different. 'n' chooses a sample,
-- 'note' plays it at a different speed, corresponding to a note.

-- Different sounds:
d1 $ n "0 1" # sound "dsynth"

-- Different notes:
d1 $ note "0 1" # sound "dsynth"ˇ

d1 $ note "0 1 2 3 4 5 6" # s "bsvocals" # legato 0.5 

-- If you pick a high note, then you'll notice the sound is a lot
-- shorter, because it's making it higher by playing it faster.
d1 $ note "0 24" # sound "dsynth"


-- You might feel that's not good, because it doesn't sound as natural
-- as a synthesiser
-- You might feel that's great, because nature is a myth and this is
-- how old school 'tracker' music from early rave music and the
-- demoscene works
-- You might change your mind on different days

-- You can still use note names in mininotation:
d1 $ note "c a f e" # sound "dsynth"

-- (Actually you can use do this in any control/effect pattern that
-- expects a number.. Tidal just treats them as numbers)

-- This dsynth sample is in 'c'. If it wasn't, the notes would
-- probably sound out of tune with another synth or samplebank.

-- The 'dbass' sample has three bass sounds, again in 'c', of
-- different lengths.  So it makes sense to use *both* 'note' and 'n'
-- together, to pattern both the pitch and the sample that's used:
d1 $ note "c a f e" # sound "dbass" # n "<0 1 2>"

-- The 'rash' samplebank is organised differently.. There's a load of
-- samples, one for each note of 6 octaves. There's 12 notes in an
-- octave, so that's 72 samples. (actually there's 73, there's an
-- extra one note-084.wav which you could delete..) I sampled these
-- from my lovely Roland JV1080 synth.

-- So you can play notes as numbers using the 'n' instead of the
-- 'note' pattern. This sounds a bit more 'natural' than pitching them
-- up with 'note'.
d1 $ n "20 50" # sound "rash"

-- You can still use note names, but whereas for synths '0' is *middle*
-- c, with these samples that's right at the *bottom* of the scale.
d1 $ n "c a f e" # sound "rash"

-- So in this case you'll want to pick a higher octave
d1 $ n "c7 a7 f8 e7" # sound "rash"

-- I tend to add a few octaves like this:
d1 $ n "c a f e" # sound "rash"
  |+ n 24

-- Adding notes together is fun :
d1 $ n "c a f e" # sound "rash"
  |+ n 24
  |+ n "<0 2 7 12>"

-- You can also do it this way, adding together number patterns
-- 'inside' a single control pattern
d1 $ n ("c a f e" |+ 24 |+ "<0 2 7 12>")
  # sound "rash"

-- There's also an 'octave' control to jump up/down in twelves:
d1 $ note "c a f e" # sound "superpiano"
  # octave "<4 6 3>"

-- Ok chords! We can play a 'major' chord like this:

d1 $ n "'maj" # sound "supermandolin"
  # legato 2 # gain 1.4

-- The default is c major, you can choose others like this, e.g. to
-- play c then e major:
d1 $ n "c'maj e'maj" # sound "supermandolin"
  # legato 2 # gain 1.4

-- Karaoke (algoraoke) time
-- Lets take the chord from a well known song:
-- https://ukutabs.com/r/radiohead/creep/

d1 $ n "<g'maj b'maj c'maj c'min>" # s "supermandolin"
  # room 0.6 # sz 0.9

-- and strum it a bit with struct:
d1 $ qtrigger 1 $ jux ((|- n "12") . rev) $ struct "t(5,8,<0 4>)" $ n "<g'maj b'maj c'maj c'min>" # s "supermandolin"
  # room 0.6 # sz 0.9

-- You can get a list of all the chords like this:
import Sound.Tidal.Chords

chordList

-- Try some out:
d1 $ n "c'sevenFlat9 a'm9sharp5" # sound "supermandolin"

-- Here's the raw data:
chordTable

-- Again, this all ends up being turned into plain note numbers. These
-- two patterns are the same:
d1 $ n "c'sevenFlat9 a'm9sharp5" # sound "supermandolin"

d1 $ n "[0,4,7,10,13] [9,10,23]" # sound "supermandolin"

-- qtrigger plays pattern at the start of the cycle
d1 $ qtrigger 1 $ jux ((|- n"16") . rev) $ struct "t(3,11)"
              $ n "<[-3,9,13,16,21] [1,9,13,16,20] [-6,9,13,16,18] [4,9,13,16] [-3,9,13,16] [6,9,13,18] [4,14,16,20] [4,14,16,20] [11,16,20,23][11,16,20,21][11,14,20][11,14,18] [4,11,14,20][-8,11,14,20][-3,9,13,16,21][1,9,13,16,21][-3,9,13,16,21][4,9,13,16,20][-6,9,13,16,18][-3,9,13,16] [10,16,18,22][6,16,18,22][-1,16,19,23][4,16,19,23][6,14,18,23][2,14,18,21][-3,13,16,21][1,13,18,22][-4,14,16,20][-8,14,16,20][-3,9,13,16,21][-8,9,13,16,21]>"
              #sound "supermandolin"
              # vowel "a e i o"
              # djf (sine |+| 0.2) 

d2 $ qtrigger 1 $ jux rev $ struct "t(3,11)" 
                $ n"<[12 17] [12 16][12 14][12 24][12 0] [12 14] [12 16] [ 12 24] [ 12 24] >"
                #sound "superpiano"
                #legato 0.5

-- You can say how many notes you want in a chord, with another ' and
-- the number of notes you want.

-- If you ask for more notes than exist in the basic chord, it will go
-- up the octaves to find more notes, sounding more and more impressive:
d1 $ n "c'maj'4" # s "superpiano"
d1 $ n "c'maj'8" # s "superpiano"
d1 $ n "c'maj'12" # s "superpiano"

-- This is clearer when we start doing.. ARPEGGIOS

-- These are 'broken' chords, where instead of playing the notes at
-- once, they're played one after another:
d1 $ arpeggiate $ n "c'maj" # s "superpiano"

-- The arpeggio happens within the 'step' that the chord occupies:
d1 $ arpeggiate $ n "c'maj e'min7" # s "superpiano"

-- Above, you can hear major chords have three notes, and minor 7
-- chords have four. You can modify that with ' so they have the same
-- number, if you want:
d1 $ arpeggiate $ n "c'maj'4 e'min7'4" # s "superpiano"

-- "arpeggiate" has a shorter, but more flexible cousin "arp", that
-- allows you to specify a different way of breaking up the chord:
d1 $ arp "updown thumbup" $ n "<c'maj'4 e'min7'4>" # s "superpiano"

-- Here's the list of currently available arp styles to explore:
-- up, down, updown, downup, converge, diverge, disconverge, pinkyup,
-- pinkyupdown, thumbup thumbupdown

-- Lots of fun
d1 $ jux rev $ arp "<updown thumbup pinkyupdown converge diverge>"
  $ n "<c4'maj'6 e4'min7'8 g5'maj'5 a5'maj'4>" # s "superpiano"
  # room 0.3 # sz 0.7

-- rockwell example 
do
d1 $ n "[~ -11 -11 -11] [-10 -10 -9 -9 -9 ~]" |+ n "<f4'min bf4'min>"  # sound "jvbass"
  |* speed "[0.5,1,2,5]/2"
  |+ hpf (range 100 800 perlin) # hpq 0.4
  |+ note "<0 4>" # room 0.4 # sz 0.7
d2 $ iter 4 $ loopAt 1 $ chop 8 $ sound "break:4"
  # gain 1.2 # speed "1 1 1 2"
  # shape 0.4

setcps 0.4

-- because 0 is C, minecraft samples are 6 or -6 because they're f# (fs in tidal)
do
d1 $ arp "updown" $ n "<fs'maj'6>" # s "mcb" # room 0.1 # sz 0.2
d2 $ n "<6 1> <1 <4 5>>" # s "mcf" # delay 0.5 # delaytime 0.3 # delayfeedback 0.4 # gain 0.8
d3 $ s "mcs ! ! ! ! ! ! ! mcs*4 mcs*4"
d4 $  s "bskick bssnare"
d5 $ s "<speech:2 speech:4>" # delay 0.2 # delaytime 0.2 # delayfeedback 0 # sine |+| 1
d6 $ n "[<11 12>!8 16!4 18!4]/2" # s "mcg" # room 0.3 # sz 0.2

-- q = quarter note, e = eighth (conflict with note naming so will change)
-- t = triplet

d1 $ "<0 q t>" <~ (n "0 2 ~ 4 0 2 ~ 5 " # s "cpu")

d1 $ n " ~ [7 9] 4 [ 3 4]" # s "cpu"
# delay 0.4 
# delayt "t"
# lock 1 
# delayfb 0.7

-- :t shows type and input/output of a function

:t fast 
:t hurry

-- random melody in scale
d1 $ struct "t(5,8)" $ n (scale "minor" (irand 7))
# s "supermandolin"
# legato 4

-- random melody from random scale
d1 $ struct "t(5,8)" $ n (scale "[major|minor|ritusen]" (irand 7))
# s "supermandolin"
# legato 4

d1 $ struct "t(5,8)" $ n (scale (choose ["ritusen", "minor"]) (irand 7))
# s "supermandolin"
# legato 4

-- choose  

:t choose

d1 $ s (segment 3 $ choose ["bd", "clap"])

-- indentation
 
do let x = 3 
   d1 $ every x rev $ sound "bd sn"

-- iter
d1 $ iter 4 $ n "0 1 2 3" # s "alphabet"

-- shifts by 1/4 of a cycle every cycle
--a b c d
--b c d a 
--c d a b
--d a b c
--therefore it takes 4 cycles to get back to the original pattern
--a b c d

-- iter' ("iter prime") shifts in the opposite direction ( haskell primes)

d1 $ iter' 4 $ n "0 1 2 3" # s "alphabet"

-- a b c d
-- d a b c
-- c d a b
-- b c d a 

d1 $ iter 8 $ loopAt 2 $ chop 8 $ s "break:2"

d1 $ iter' 8 $ loopAt 2 $ chop 8 $ s "break:3"

d1 $ chunk 4 (hurry 2) $ iter' 4 $ loopAt 2 $ chop 8 $ s "break:8"

-- canons with off 

-- Let's start with two notes:
d1 $ n "c e" # sound "supermandolin"

-- What does 'off' do? Switch between the above and below versions to hear
-- the difference.
d1 $ off 0.25 (# crush 4) $ n "c e" # sound "supermandolin"

-- You can hear that the original two notes are untouched, but there is
-- something else added.

-- 'off' takes three inputs; a number, a function and a pattern.
-- What it does is leave the original pattern as is, but adds a copy of
-- it on top. That copy is offset in time by the number given in the first
-- input - the number. The copy also has the function applied to it.
-- So we end up with a version of the pattern that 'follows' the original
-- in time, and is transformed. In this case, it is distorted.

-- Instead of using the bitcrush effect, lets add to the 'n' note, instead.
d1 $ off "0.25" (|+ n 7) $ n "c e" # sound "supermandolin"

-- Now we hear a simple 'canon' - it sounds like one voice following another.

-- We can swap '0.25' for the shorthand 'q', which stands for a *q*uarter of a
-- cycle.
d1 $ off "q" (|+ n 7) $ n "c e" # sound "supermandolin"

-- Lets change that for 'e', which stands for an eighth of a cycle.
d1 $ off "e" (|+ n 7) $ n "c e" # sound "supermandolin"

-- Here's the current list of shorthands available:
-- w = 1 (whole)
-- h = 0.5 (half)
-- q = 0.25 (quarter)
-- e = 0.125 (eighth)
-- s = 0.0624 (sixteenth)
-- t = 1/3 (third)
-- f = 0.2 (fifth)

-- You can have multiples of these shorthands by prefixing them with a
-- number, for example:
d1 $ off "2f" (|+ n 7) $ n "c a f e" # sound "supermandolin"

-- For a 32nd, you could do 0.5s:
d1 $ off "0.5s" (|+ n 7) $ n "c a f e" # sound "supermandolin"

-- Let's try with a more complex pattern:
d1 $ off "e" (|+ n 7) $ n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
  # sound "supermandolin"

-- The notes are getting very short now, to match the shorter 'step' sizes
-- within this denser pattern. To make them proportionally longer we can
-- use legato, for example to make them all twice as long:
d1 $ off "e" (|+ n 7) $ n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
  # sound "supermandolin"
  # legato 2

-- Or alternatively we can use sustain for a duration in seconds:
d1 $ off "e" (|+ n 7) $ n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
  # sound "supermandolin"
  # sustain 0.75

-- We can pattern the 'n' of the transformed version of the pattern:
d1 $ off "e" (|+ n "<7 12 -5>") $ n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
  # sound "supermandolin"
  # sustain 0.75

-- In the above the 7 - 12 - -5 pattern repeats every third cycle, and the
-- c a f e one repeats every two cycles (due to the slow 2). The combination
-- of (or interference between) them repeats lasts six cycles.

-- Lets add another 'off', this time offset by a sixteenth of a cycle, and
-- dropping the octave.
d1 $ off "s" (|+ n (-12)) $ off "e" (|+ n "<7 12 -5>") $
 n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
 # sound "supermandolin"
 # sustain 0.75

-- Note that negative numbers have to be in parenthesis, otherwise Haskell
-- gets confused and things you're trying to do a subtraction!

-- This isn't the case in the mininotation, so an alternative is to put
-- all negative numbers in double quotes:
d1 $ off "s" (|+ n "-12") $ off "e" (|+ n "<7 12 -5>") $
 n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
 # sound "supermandolin"
 # sustain 0.75

-- The same principles can be applied to percussion, for example:
d1 $ off "<s q e>" (# squiz 2) $ n "{0 1 [~ 2] 3*2, 5 ~ 3 6 4}"
  # sound "cpu2"
  # sustain 0.75

-- Notice the offset is patterned in the above, so the 'following'
-- pattern shifts forwards and backwards.

-- The 'arpy' folder contains sounds sampled using a pentatonic
-- 'ritusen' scale, starting with 'c'. In this scale there are five
-- notes per octave.  So these are the same notes:
d1 $ n "0 5" # sound "arpy"

d2 $ n "0 12" # sound "superpiano"

-- Pentatonic scales like this are nice to work with because they all
-- sound good together. So if we add a random note to a melody, it
-- always sounds 'good':

d1 $ n ("0 [7 2] 3 2" |+ irand 3) # sound "arpy"

-- This isn't really the case on the usual twelve-tone "equal
-- temperament" (12-TET) scale:
d1 $ n ("0 [7 2] 3 2" |+ (irand 3)) # sound "superpiano"

-- 12-TET is the scale that pianos etc are normally tuned to in the west.

-- To use a different scale, we can use the "scale" function for converting
-- numbers from a different scale to 12-TET.
d1 $ n (scale "ritusen" $ "0 [7 2] 3 2" |+ (irand 3))
  # sound "superpiano"

-- There's quite a few available:
scaleList

-- It's fun to use waveforms to pick notes from a scale. For example,
-- use a smooth sinewave to select notes from a minor scale:
d1 $ segment 16 $ n (scale "minor"
                     $ floor <$> (range 0 14 sine)
                    )
  # sound "supersaw"
  # legato 0.5
  # lpf 1000 # lpq 0.1

-- Remember that waveforms don't have structure, so don't produce
-- events until you use something like 'segment', which in the example
-- above picks 16 notes per cycle.

-- There's also a complication that waveforms produce 'floating point'
-- decimal numbers, but scale only accepts 'integers' - whole numbers.
-- The 'floor <$>' bit converts from decimal to whole numbers.  The
-- "range 0 14" bit converts from the usual range of 0 to 1 to the
-- given range of 0 to 14.

-- We can make this more exciting by patterning the range:
d1 $ segment 16 $ n (scale "minor"
                     $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine)
                    )
  # sound "supersaw"
  # legato 0.5
  # lpf 1000 # lpq 0.1

-- And maybe even more exciting by using 'struct' to pattern the
-- rhythm using Euclidean syntax.. Taking the opportunity to pattern
-- the lpf (low pass filter) as well:
d1 $ struct "t(<9 7>,16)"
  $ n (scale "minor"
        $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine)
      )
  # sound "supersaw"
  # legato 0.5
  # lpf (range 400 5000 saw) # lpq 0.1



-- Using scales in this way allows us to play with movement while
-- still making tunes that make 'sense'. Here I add together
-- waveforms to create some longer-form movement:
d1 $ segment 16 $
  n (scale "minor"
      $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"
                  )
    )
  # sound "supersaw"
  # legato 0.5
  # bpf (range 400 5000 sine) 
  # lpf (range 400 5000 saw) # lpq 0.1

-- Back with the struct:
d1 $ struct "t(<9 7>,16)" $
  n (scale "minor"
      $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"
                  )
    )
  # sound "supersaw"
  # legato 0.5
  # lpf (range 400 5000 saw) # lpq 0.1

-- And with an 'off' going up an octave:
d1 $ off 0.25 (|+ n 12) $ struct "t(<9 7>,16)" $ segment 16 $
  n (scale "minor"
      $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"
                  )
    )
  # sound "supersaw"
  # legato 0.5
  # lpf (range 400 5000 saw) # lpq 0.1

-- Note that in the above the 'off' is outside of the 'scale'
-- function, So we're back in 12-TET land, so add '12' to go up an
-- octave, rather than the number of notes in the minor scale (7)

-- Composing patterns together

-- We've already looked at different ways of composing patterns
-- together. Something as simple as this is a composition:

d1 $ fast "1 2 3 4" $ sound "lt mt ht bd*2"

-- Not a super interesting one, but it composes together a pattern of
-- densities, and a pattern of sounds, to create a new pattern that is
-- more than the sum of its parts.

-- In this lesson though we're going to look at ways to compose what
-- you could call 'independent' patterns, where one isn't used to
-- manipulate the other.

-- Tidal is often used in live situations, but there are some
-- functions that help you assemble multiple patterns into something
-- like a complete 'piece', such as a structured four-minute track.

-- Before we get to that, lets look at some extra-simple ways of
-- composing patterns together.. as they can be surprisingly useful

-- First, there's `overlay` that simply plays the two given patterns
-- at the same time:
d1 $ overlay (fast "1 2 3 4" $ sound "lt mt ht ~")
             (sound "clap:4(3,8)" # speed 2)

-- Similar to this is `stack`, which lets you overlay any number of
-- patterns on top of each other. People tend to use this rather than
-- `overlay`, as it's more flexible:
d1 $ stack [(fast "1 2 3 4" $ sound "lt mt ht ~"),
            (sound "clap:4(3,8)" # speed 2),
            sound "[kick:5(5,8), snare:3(7,16,3)]"
           ]

-- The above composes a list of three patterns together. You can see that
-- a list is given using square brackets ('[' and ']'), with the patterns
-- in the list separated by commas (','). You have to remember *not* to
-- put a comma at the end of the list, only between the elements.

-- The above might not seem too useful, as you could do the same with
-- separate patterns. This sounds exactly the same as the above:
do 
d1 $ fast "1 2 3 4" $ sound "lt mt ht ~"
d2 $ sound "clap:4(3,8)" # speed 2
d3 $ sound "[kick:5(5,8), snare:3(7,16,3)]"

-- Remember though that stack combines everything into a single
-- pattern. This is useful as you can manipulate all those patterns as
-- one. For example:
d1 $ chunk 4 (hurry 2) $
  stack [(fast "1 2 3 4" $ sound "lt mt ht ~"),
         (sound "clap:4(3,8)" # speed 2),
         sound "[kick:5(5,8), snare:3(7,16,3)]"
        ]

-- Or adding a parameter that applies to the whole stack:
d1 $ stack [(fast "1 2 3 4" $ sound "lt mt ht ~"),
            (sound "clap:4(3,8)" # speed 2),
            sound "[kick:5(5,8), snare:3(7,16,3)]"
           ] # squiz "<0 2>"

-- So `overlay` and `stack` stack things up, so that they happen at
-- the same time. Howabout sticking things together over time, so they
-- happen one after another?

-- Like overlay and stack, there is one function, 'append' for
-- composing two patterns together, and another, 'cat' for composing a
-- list of patterns together.

-- For two patterns:
d1 $ append (fast "1 2 3 4" $ sound "lt mt ht ~")
            (sound "clap:4(3,8)" # speed 2)

-- For a list of patterns:
d1 $ cat [fast "1 2 3 4" $ sound "lt mt ht ~",
          sound "clap:4(3,8)" # speed 2,
          sound "[kick:5(5,8), snare:3(7,16,3)]"
         ]

-- Again, you'll see `cat` used more often than `append`.

-- `append` and `cat` maintain the original 'density' of the patterns,
-- taking one cycle per cycle.

-- There are variants `fastappend` and `fastcat`, that take a cycle
-- from each of the patterns, and squash them all into a single cycle:

-- For two patterns:
d1 $ fastappend (fast "1 2 3 4" $ sound "lt mt ht ~")
  (sound "clap:4(3,8)" # speed 2)

-- For a list of patterns:
d2 $ fastcat [fast "1 2 3 4" $ sound "lt mt ht ~",
              sound "clap:4(3,8)" # speed 2,
              sound "[kick:5(5,8), snare:3(7,16,3)]"
             ]

-- That's fine, but what if you don't want to loop between patterns a
-- cycle at a time, but have something between a `stack` and a `cat`,
-- where you can have the patterns overlap? `seqPLoop` is one answer.

-- With `seqPLoop`, you say when each pattern starts and stops.
-- Lets first emulate the `cat` from earlier, by having each
-- pattern last one cycle.
d1 $ seqPLoop [(0, 1, fast "1 2 3 4" $ sound "lt mt ht ~"),
               (1, 2, sound "clap:4(3,8)" # speed 2),
               (2, 3, sound "[kick:5(5,8), snare:3(7,16,3)]")
              ]

-- Now let's adjust the starts and stops, so the first two overlap by
-- a pattern, then there's a gap of a cycle before the last one plays:
d3 $ seqPLoop [(0, 2, fast "1 2 3 4" $ sound "lt mt ht ~"),
               (1, 3, sound "clap:4(3,8)" # speed 2),
               (5, 6, sound "[kick:5(5,8), snare:3(7,16,3)]")
              ]

-- If you want to use the same pattern more than once, you can give it a name
--, like this:
let florence = fast "1 2 3 4" $ sound "lt mt ht ~"
in
d1 $ seqPLoop [(0, 2, florence),
               (1, 3, sound "clap:4(3,8)" # speed 2),
               (3, 4, sound "[kick:5(5,8), snare:3(7,16,3)]"),
               (3, 5, florence # coarse 5)
              ]

-- If you don't want the pattern sequence to loop, then use
-- seqP. You'll need to use something like `qtrigger`, so it starts
-- from cycle 0
d1 $ qtrigger 1 $ seqP [(0, 2, fast "1 2 3 4" $ sound "lt mt ht ~"),
                        (1, 3, sound "clap:4(3,8)" # speed 2),
                        (5, 6, sound "[kick:5(5,8), snare:3(7,16,3)]")
                       ]

 -- Composing functions together

-- Lets say you wanted to both chop up, _and_ reverse this pattern,
-- every 3 cycles.
d1 $ sound "bd [~ sd] bd sd" # squiz 2

-- You could do it like this:
d1 $ every 3 (rev) $ every 3 (chop 8) $
  sound "bd [~ sd] bd sd" # squiz 2

-- That works, but is a bit fiddly. This is where the `.` operator
-- comes in handy, by turning two functions into one:
d1 $ every 3 (rev . chop 8) $
  sound "bd [~ sd] bd sd" # squiz 2

-- That works the same, but with less typing, good!

-- You can just think of the `.` as piping together two functions
-- into one.

-- But technically speaking:, the `.` will take the input, pass it into the
-- function on the right, take the output from _that_ function, pass
-- it to the function on the left, and finally return the return of
-- _that_ function.

-- You can keep piping in more functions, if you want:
d1 $ every 3 (rev . chop 8 . fast 2) $
  sound "bd [~ sd] bd sd" # squiz 2

-- You can also add in effects:
d1 $ every 3 ((# room 0.7) . rev . chop 8 . fast 2) $
  sound "bd [~ sd] bd sd" # squiz 2

-- beat example

d1 $ ur 16 "[bdsd, ~ claps, ~ [bass bass:crunch] ~ bass]"
  [("bdsd", sound "bd [~ sd] bd sd" # squiz 2),
   ("claps", sound "clap:4*2 clap:4*3"
     # orbit 4 # speed 4
     # djf (range 400 5000 sine)
   ),
   ("bass", struct "t(3,8)" $ sound "dbass" # shape 0.7 # speed "[1, ~ 2]")
  ]
  [("crunch", (# crush 3))
  ]



  -- SHIFTING TIME

-- Lets start with a rhythm:
d1 $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2"

-- That's repeating nicely. Keep it running, then run this:
d1 $ 0.25 <~ (n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2")

-- If you switch between them, you can hear the pattern is shifting in
-- time. The `0.25` means it's shifting by a quarter of a cycle.

-- You only hear any difference between them at the point where you
-- switch to the other one. You're jumping forward / backward in time,
-- but once you're there, nothing has changed. (!)

-- Ok, time travel is difficult to talk about.

-- Lets visualise this, compare these two:
drawLine "a b c d"

drawLine $ 0.25 <~ "a b c d"

-- You can see the a b c d sequence is the same, but in the latter
-- case, the cycle begins on the 'b'.

-- So '<~' has moved us _forward_ into the future. So shouldn't it be
-- '~>', rather than '<~'?? Well, we might have moved into the future,
-- but it's all relative - from the perspective of the pattern, it's
-- moved backwards into the past. Furthermore, while we like to think
-- about us moving forwards into the future, from the perspective of
-- the future, it's moving backwards into the past. Furthermore
-- different human cultures think about time in different ways.

-- Anyway, '~>' does indeed exist, compare these two:

drawLine $ 0.25 <~ "a b c d"

drawLine $ 0.25 ~> "a b c d"

-- Time is most interesting if you keep jumping around
-- For example jump every 3 cycles:
d1 $ every 3 (0.25 <~) $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2"
  # crush 4

-- Jumping in the other direction has quite a different feel:
d1 $ every 3 (0.25 ~>) $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2"
  # crush 4

-- You can also use a pattern for the time shift amount:
d1 $ "<0 0.25 0.75>" ~>
  (n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2" # crush 4)

-- Even with this straightforward shifting, things quickly start
-- sounding 'random', until your ears lock on to the longer loop..

-- SIDETRACK - a note on syntax..

-- Unfortunately this use of the dollar *doesn't work*:
d1 $ "<0 0.25 0.75>" ~> $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]"
  # sound "cpu2" # crush 4

-- This is because like all operators, you can't use a dollar to group
-- together a pattern to send to `~>` in this way. haskell gets
-- confused about seeing two operators ('$' and '~>') next to each
-- other.

-- So you have to use parenthesis:
d1 $ "<0 0.25 0.75>" ~> (n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]"
  # sound "cpu2" # crush 4)

-- Or another way around this is to wrap the *operator* in
-- parenthesis, then you can use it like a normal function:
d1 $ (~>) "<0 0.25 0.75>" $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]"
  # sound "cpu2" # crush 4

-- Or wrap the first input and the operator in parenthesis:
d1 $ ("<0 0.25 0.75>" ~>) $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]"
  # sound "cpu2" # crush 4

-- This all works nicely with chopped-up loops:
d1 $ every 2 ("e" <~) $ every 3 (0.25 <~) $
  loopAt 1 $ chop 8 $ sound "break:8"

-- BINARY PATTERNS

-- The patterns you send to SuperDirt tend to contain values of type
-- String (for words), Double (for decimal numbers) or Int (for whole
-- numbers). One pattern type you probably won't send to SuperDirt is
-- of type Bool - short for Boolean.

-- Boolean values can be either True or False. You've probably seen
-- then used with with 'struct', e.g.:

d1 $ struct "t f t t f t f f" $ sound "snare:4"


-- 'struct' provides structure for the pattern on the right; whenever
-- there's a 't' (i.e., a true value) in the boolean pattern, the
-- snare fires.

-- It works with euclidean syntax too:
d1 $ struct "t(3,8)" $ sound "snare:4"

-- The above creates a new pattern with three events per cycle,
-- according to a Euclidean pattern.

-- Lets have a look at that euclidean pattern:
drawLine $ struct "t(3,8)" "a"

-- So what do you think would happen if you changed that 't' (for
-- true) for an 'f' (for false)? Lets try:
drawLine $ struct "f(3,8)" "a"

-- Lets listen to that structure too:
d1 $ struct "f(3,8)" $ sound "snare:4"

-- You can see and hear that the *inverse* of the Euclidean pattern is
-- played. What was true, is now false, and vice-versa.. It's the
-- 'empty' steps which get the true values, and which we end up
-- hearing.

-- This is clearer if we play a t(3,8) against an inverted f(3,8):
d1 $ stack [struct "t(3,8)" $ sound "kick:4",
            struct "f(3,8)" $ sound "snare:4"
           ]

-- You can hear that the snares are 'filling in' where the kicks
-- aren't playing - they never play at the same time.

-- Filling in patterns like this is a lot of fun, and there's a
-- function called 'stitch' that makes it easier:
d1 $ stitch "t(3,8)" (sound "kick:4") (sound "snare:4")

-- You only have to give the boolean pattern once, 'stitch' takes care
-- of inverting the pattern for the second pattern. It's called
-- 'stitch', because it's like going up and down to stitch two things
-- together.

-- You can make more complicated boolean patterns to quickly get some
-- fun patterns going:
d1 $ stitch "t(<3 5>,8,<0 2 3>)" (sound "kick:4") (sound "hc")

d1 $ stitch "t(<3 5>,<8 8 8 6>,<0 2 4>)" (sound "kick:4") (sound "hc")

drawLine $ stitch "t(<3 5>,<8 8 8 6>,<0 2 4>)" ("t") ("f")

-- Actually it'd be less typing do the stitching _inside_ the sound
-- control pattern:
d1 $ sound (stitch "t(<3 5>,<8 8 8 6>,<0 2 4>)" "kick:4" "hc")

-- In the above, I only have to write 'sound' once, because the
-- 'stitch' is working on patterns of words, not patterns of sounds.

-- You can also alternate between patterns of true, and patterns of false
-- values:

drawLine $ struct "<t f>(3,8)" "a"

d1 $ struct "<t f>(3,8) " $ s "555fortruth:9"
-- If you prefer you can use '1' or '0' instead of 't' and 'f', the
-- result is exactly the same:
drawLine $ struct "<1 0>(3,8)" "a"

d1 $ struct "<1 0>(3,8)" $ sound "clap"

-- You don't have to use the Euclidean syntax, you can just right them
-- out by hand:
d1 $ stitch "t f t t f f t f" (sound "kick:4") (sound "hc")

-- .. and use the usual mininotation syntax:
d1 $ stitch "t f t [t f]*2 f ~ t f" (sound "kick:4") (sound "hc")
  # room 0.2 # sz 0.8

-- With stitch, the rhythmic structure comes from the boolean
-- pattern. It has a synonym friend called 'sew', which instead
-- preserves the structure of the patterns it's sewing together.

-- Lets try it:
d1 $ sew "t f" (sound "kick") (sound "clap:4")

drawLine $ sew "t f" ("t") ("f")

-- Oh! We only hear the kick. That's because the 'f' only switches to
-- the second pattern for the second half of the cycle, and no new
-- 'clap's happen then.

-- If we have four claps spread over the cycle, we hear the second two
-- of them:
d1 $ sew "t f" (sound "kick") (sound "clap:4*4")

drawLine $ sew "t f" ("t") ("f*4")

-- Sew can be really nice for blending together two more complicated
-- patterns. Lets have a listen to them individually first:

d1 $ chunk 4 (hurry 2) $ n "0 .. 7" # sound "cpu"

d1 $ n "0 .. 7" # sound "cpu2" # speed 1.5 # squiz 2

-- And now sewn:
d1 $ sew (iter 4 "t f")
  (chunk 4 (hurry 2) $ n "0 .. 7" # sound "cpu")
  (n "0 .. 7" # sound "cpu2" # speed 1.5 # squiz 2)

-- In the above I have a really simple "t f" binary pattern, but use
-- 'iter 4' so that it shifts by a quarter every cycle.. So you get
-- different parts of the sewn patterns coming through.

-- Function of the Week: "weave" !

-- Weave is an interesting one. It's used to 'weave together' a list
-- of patterns, using an additional control pattern. So it's a bit
-- like the warp and weft of a textile weave.

-- Lets start with some numbers:

d1 $ n "0 1 2 3" # s "numbers"

-- Lets first understand what happens if you use weave on a single
-- pattern:
d1 $ weave 4 (pan saw)
  [n "0 1 2 3" # s "alphabet"]

-- You can hear the pattern panning from left to right over four
-- cycles.

-- In the above, the '4' is used to slow down the 'pan saw' effect,
-- before it's applied to the 'n "0 1 2 3" # s "numbers"' pattern. It
-- sounds identical to the following:

d1 $ n "0 1 2 3" # s "numbers"
  # pan (slow 4 saw)

-- So why not just do that - what's the point of the weave function?
-- Lets hear what happens when you use it with two patterns:

d1 $ weave 4 (pan saw)
  [n "0 1 2 3" # s "numbers",
   n "0 1 2 3" # s "alphabet"
  ]

-- Aha! You should be able to hear that the patterns are placed at
-- different parts of the panning effect. So 'weave' is acting a bit
-- like a wacked-out 'stack'. The patterns are stacked up, each with
-- the 'pan' control pattern applied, but with the pan control shifted
-- so that one is at the start of the pan, the other is halfway
-- through. They're kind of chasing after each other across the pan.

-- The following sounds identical to the above:

d1 $ stack [n "0 1 2 3" # s "numbers"
            # pan (slow 4 saw),
            n "0 1 2 3" # s "alphabet"
            # pan (2 <~ (slow 4 saw))
           ]

-- Here's a more musical example:
d1 $ weave 4 (pan saw)
  [n "[0*2 0*3, [~ 3]*2, 4(3,8,<0 2>)]" # s "cpu" # squiz 2,
   fast 2 $ brak $ n "0 4 3 <[~ 3] 3>" # s "cpu2"
  ]

-- If we add another pattern, so that we now have 3, things go
-- a bit off-kilter:
d1 $ weave 4 (pan saw)
  [n "[0*2 0*3, [~ 3]*2, 4(3,8,<0 2>)]" # s "cpu" # squiz 2,
   fast 2 $ brak $ n "0 4 3 <[~ 3] 3>" # s "cpu2",
   sound "~ clap:3*2" # speed 2
  ]

-- That's because three events are spreading out over four cycles, so
-- they're out by four thirds of a cycle, which sounds like being out
-- by a third of a cycle. Sounds interesting!

-- Once we add a fourth, things fall back into a 4:4 structure:
d1 $ weave 4 (crush saw)
  [n "[0*2 0*3, [~ 3]*2, 4(3,8,<0 2>)]" # s "cpu" # squiz 2,
   fast 2 $ brak $ n "0 4 3 <[~ 3] 3>" # s "cpu2",
   sound "~ clap:3*2" # speed 2,
   sound "bd(3,8,<0 2>)" # shape 0.85
  ]

-- 'saw' gives a smooth, linear movement from left to right. Some more
-- to experiment with (replace `pan saw` for one of these):

-- pan "0 0.25 0.5 0.75"
-- pan sine

-- It works for things other than panning, too, try:
-- crush (saw * 8)
-- vowel "a e i o u"

-- It works with global effects like reverb too, but you have to put
-- each pattern on its own 'orbit', so that they have separate global
-- effects:
d1 $ weave 8 (room saw # sz saw)
  [n "[0*2 0*3, [~ 3]*2, 4(3,8,<0 2>)]" # s "cpu" # squiz 2 # orbit 0,
   fast 2 $ brak $ n "0 4 3 <[~ 3] 3>" # s "cpu2" # orbit 1,
   sound "~ clap:3*2" # speed 2 # orbit 2,
   sound "bd(3,8,<0 2>)" # shape 0.85 # orbit 3
  ]

-- Things get especially weird when you swap things round so that it's
-- the samples/notes that are being applied to effect patterns.

d1 $ weave 8 (note "c e f g" # s "supermandolin" # legato 2)
  [vowel "a e i"] # gain 1.3

-- and with more patterns:
d1 $ weave 8 (every 2 rev $ n (scale "ritusen" "0 .. 7")
              # s "rash"
             )
  [vowel "a e i",
   vowel "o(5,8,<0 2>)",
   squiz "0 3*2 4 7"
   room "0 0.25 0.7 0.99" # orbit 3
  ] |+ n 24


-- There's also a function 'weaveWith', which works with functions,
-- rather than control patterns..
d1 $ weaveWith 8 (every 2 rev $ n (scale "ritusen" "0 .. 7")
                  # s "rash"
                 )
  [(+| vowel "a e i*2"),
   (+| n "0 12*2 0 12"),
   hurry 2,
   off 0.25 (|+ n "-24") . struct "t(5,8,<0 2>)" . hurry 4
  ] |+ n 24


  -- Lets fit things from a list, into a pattern!

-- Here's the 'type signature', what's it telling us?
fit :: Int -> [a] -> Pattern Int -> Pattern a

-- 'fit' takes a whole number, a list of things, a pattern of whole numbers,
-- and then gives back a pattern of things.

-- Int - a 'step size' - how far to advance through the list each cycle
-- [a] - a list - the things you want to put in the tattern
-- Pattern Int - a pattern of numbers referring to things in the list
-- Pattern a - the result! 'Pattern a' means it can work with any kind of
-- pattern

-- Let's start simple, with a step size of 0

d1 $ n (fit 0 [9,10,11,12,13,14] "0 1 2 3") # s "alphabet"

-- That's just cycling through four letters of the alphabet (j,k,l,m).
-- We have six numbers in our list, but we're only using the first four
-- (from 0 to 3).

-- Let's use all six, and add a bit more structure:
d1 $ n (fit 0 [9,10,11,12,13,14] "[0 3] [1 2] 4 [~ 5]") # s "alphabet"

-- Note that if you go past the end of the list, you go back to the start again.
-- So '0' and '6' end up pointing at the first of the six numbers, which is '9'
-- (which gives us 'j')
d1 $ n (fit 0 [9,10,11,12,13,14] "0 6") # s "alphabet"

-- Ok what if we start playing with that 'step size'?
d1 $ n (fit 1 [9,10,11,12,13,14] "0 1 2 ~") # s "alphabet"

-- It starts getting confusing, but you should be able to hear that each cycle,
-- the pattern moves through the list by one step, until it gets back to the
-- start again. So if it starts from 'j', 'k', 'l', the next cycle it'll shift
-- along by one and give 'k', 'l', 'm', and so on, until it starts wrapping
-- around to the start again.

-- This can be nice for generating melodies. The rhythm stays the same, but
-- the notes evolve, moving through the pattern
d1 $ note (fit 2 [0,2,7,5,12] "0 ~ 1 [2 3]") # sound "supermandolin"
  # legato 2 # gain 1.3

d2 $ n "0 ~ 2 [3*2 4*2]" # sound "cpu" # speed 2